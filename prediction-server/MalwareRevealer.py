import requests as req
import importlib
import models
import json
import os
import torch
from torchvision import transforms
from PIL import Image
from io import BytesIO
import pandas as pd
import numpy as np

MODEL_STORE = "models-data"
EXTRACTION_ENDPOINT = "http://extractor/extract"


def download_image(url):
    """
    Download the image using the url provided, create a Pillow image from it
    and returns it.
    """
    resp = req.get(url)
    buffer = BytesIO(resp.content)
    image = Image.open(buffer)
    return image


class MalwareRevealer():

    def __init__(self, version):
        model_version_dir = os.path.join(MODEL_STORE, version)
        self.extractor_conf = model_version_dir + "/extractor_conf.yaml"
        self.model = models.new(version)
        self.version = version


    def get_features_(self, exec):
        files = {
            'exec': exec,
            'extractor_conf': open(self.extractor_conf, 'rb')
        }
        resp = req.post(EXTRACTION_ENDPOINT, files=files)

        return resp


    def get_features(self, exec):
        """
        Should get the features from the appropriate attr according to
        the extractor used.
        """
        raise NotImplementedError()


    def predict(self, features):
        raise NotImplementedError()


class MalwareRevealerCnn(MalwareRevealer):

    def __init__(self, version):
        super().__init__(version)
        self.categories = ['benign', 'malware']
        self.data_transform = transforms.Compose(
            [
                transforms.Resize(224),
                transforms.ToTensor(),
            ]
        )


    def get_features(self, exec):
        response = self.get_features_(exec)
        json_data = json.loads(response.text)
        image_url = json_data['image_urls']['binary_image']
        image = download_image(image_url)

        return image


    def predict(self, image):
        image = image.convert("RGB")
        image_tensor = self.data_transform(image)
        image_tensor = image_tensor.unsqueeze(0)
        with torch.no_grad():
            out = self.model(image_tensor)
            probs = out[0]
            probs = probs.softmax(0)

        cats = self.categories
        probs_cats = {cat: float(prob) for prob,cat in zip(probs, cats)}

        return probs_cats


class MalwareRevealerLR(MalwareRevealer):

    def __init__(self, version):
        super().__init__(version)
        self.categories = ['benign', 'malware']
        self.columns = [
            "avg_length",
            "byte_count_mean",
            "byte_count_median",
            "has_characteristics",
            "has_debug",
            "has_resources",
            "has_signature",
            "has_tls",
            "section_counts",
            "has_symbols",
            "paths_count",
            "registry_count",
            "has_weird_sections",
            "file_size",
            "sizeof_code",
            "virtual_size",
            "url_counts",
        ]


    def get_features(self,exec):
        response = self.get_features_(exec)
        json_data = json.loads(response.text)
        row_data = self.clean_features(json_data, self.columns)

        return row_data

    def predict(self,features):
        dataframe = pd.DataFrame(columns=self.columns)
        dataframe = dataframe.append(features, ignore_index=True)
        dataframe = dataframe.reindex(sorted(dataframe.columns), axis=1)
        predict = self.model.predict_proba(dataframe)
        return {self.categories[0]: predict[0][0], self.categories[1]: predict[0][1]}

    def clean_features(self,file,columns):

        not_defult_columns = [
            "byte_count_median",
            "byte_count_mean",
            "has_characteristics",
            "has_symbols",
            "has_weird_sections"
        ]

        try:
            row = {key: file[key] for key in columns if key not in not_defult_columns}
            byte_count = np.array(file['byte_count'])
            row['byte_count_mean'] = byte_count.mean()
            row['byte_count_median'] = np.median(byte_count)
            row['has_characteristics'] = int(len(file['characteristics']) > 0)
            row['has_symbols'] = int(file['symbols'] > 0)
            ## we know that all normal sections in the pe files should start with "." like ".data" or ".rdata" so we look at the names of the sections in the files once we find
            # a section with a name that not start with . we set the "has_weird_sections" to 1 to say that there is a not normal sections
            row['has_weird_sections'] = int(len([1 for i in list(file['sections'].keys()) if not i.startswith(".")]) > 0)
            ### the one hot encodeing part
            ### DLL_charactiristics
            ### we have a limited number of dll_char
            dll_char = ['DYNAMIC_BASE', 'FORCE_INTEGRITY','GUARD_CF','HIGH_ENTROPY_VA','NO_BIND','NO_ISOLATION','NO_SEH','NX_COMPAT','TERMINAL_SERVER_AWARE']
            row = self.one_hot_encoding(row, dll_char, file['dll_characteristics'],prefix='dll_char')

            ### for the SUBSYSTEM it's the same thing we have 4 diffrent types her
            subsystem = ['SUBSYSTEM.NATIVE ','SUBSYSTEM.WINDOWS_BOOT_APPLICATION','SUBSYSTEM.WINDOWS_CUI','SUBSYSTEM.WINDOWS_GUI' ]
            row  = self.one_hot_encoding(row,subsystem,[file['subsystem']],prefix='subsys_')
                ### for the imported fucntions
            imported_functions = ['CloseHandle ' ,'GetCurrentProcess','GetCurrentProcessId' ,'GetCurrentThreadId','GetLastError','GetProcAddress',
                                'SetUnhandledExceptionFilter' ,'Sleep','TerminateProcess','UnhandledExceptionFilter']
            row  = self.one_hot_encoding(row,imported_functions,file['imported_functions'],prefix='imp_func')

            ## for the dll libs
            libs = ['ADVAPI32.dll ','GDI32.dll','KERNEL32.dll','OLEAUT32.dll' , 'SHELL32.dll', 'USER32.dll','kernel32.dll','msvcrt.dll' , 'ntdll.dll', 'ole32.dll' ]
            row  = self.one_hot_encoding(row,libs,file['libs'],prefix='dll_libs')


        except:
            pass
        return row

    def one_hot_encoding(self,row,columns,data,prefix):
        for feature in columns:
            if feature in data:
                row[prefix + '_' + feature] = 1
            else:
                row[prefix + '_' + feature] = 0
        return row

def new(version):
    if version.startswith('cnn'):
        return MalwareRevealerCnn(version)
    elif version.startswith('LogisticRegression'):
        return MalwareRevealerLR(version)
    else:
        return None
